# 设计模式/デザインパターン/Design Pattern
设计模式/デザインパターン/Design Pattern
 (行为型模式、结构型模式、创建型模式)

一、策略模式 Strategy Pattern</br>
    分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是：
  分离变化部分，封装接口，基于接口编程各种功能。此模式让行为算法的变化独立于算法的使用者。
  
二、装饰着模式 Decorator Pattern</br>
    动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性。
  就像打包一个快递一样。子类去调用父类的方法，并在自己的方法中对其进行加强。
  
三、观察者模式 Observer Pattern</br>
    对象之间多对一依赖的一种设计方法，被依赖的对象为Subject，依赖的对象为Observer,Subject通知Observer变化。
  多对1： Observer 对 Subject。 其业务类型，有点类似于订阅邮件。
  
四、单例模式 Single Pattern</br>
   私有化构造方法，对外提供全局访问的返回单一对象的方法。确保一个类最多只有一个实例，并提供一个全局访问点。
         多线程中保持一致性。
         饱汉式和饿汉式。
         
五、工厂模式 Factory Patterns</br>
    1.简单工厂模式原理</br>
      定义一个创建对象的类（工厂类），由这个类来封装实例化对象的行为。外部从工程类中获取相应实例。
    2.工厂方法模式（重要）</br>
      定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。
    3.抽象工厂模式（重要）</br>
      定义了一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类。用一个接口引用去调用工厂方法，在主程序中创建具体的接口引用对象。
      有点类似于策略模式。
      
六、命令模式 Command Pattern</br>
    将请求、命令、动作等封装成对象，这样可以让项目使用这些对象来参数化其他对象。使得命令的请求者和执行者解耦。
    
七、适配器模式 Adapter Pattern</br>
    1.对象适配者模式：适配器类实现目标接口，实现方法中调用被适配者类的方法
    2.类适配者模式：适配器类实现目标接口，并继承被适配者类，实现方法中调用父类（被适配者类）方法。
    
八、外观模式 Appearance Pattern</br>
    提供一个统一的接口，来访问子系统中一群功能相关接口。
   外观模式定义了一个高层接口，让子系统更容易使用。
   
九、模板模式 Tempalte Pattern</br>
   一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式（超类的模板方法）进行。这种类型的设计模式属于行为型模式。

十、迭代器模式 Iterator Pattern</br>
   提供一种方法顺序访问一个聚合对象中的各个对象。
   
十一、组合模式 Package Pattern</br>
    将对象聚合成树形结构来表现"整体/部分"的层次结构。
    组合模式能让客户以一致的方式来处理个别对象以及对象组合。
    
十二、状态模式 State Pattern</br>
    每个状态封装成一个类，并实现所有公共方法类的接口。
  能根据内部状态的变化，改变对象的行为，看起来好像改变了类。
  本质上调用现在所处状态的行为
  
十三、代理模式 Proxy Pattern</br>
   一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。
  在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。
  
十四、组合模式</br>
    模式经常一起使用，组合在一个设计解决方案中
   复合模式在一个解决方案中结合两个或多个模式。如MVC模式
   
十五 、桥接模式 Bridge Pattern</br>
    用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化       之间的桥接结构，来实现二者的解耦。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。
        
十六、生成器模式 Builder Pattern</br>
     封装一个复杂对象构造过程，并允许按步骤构造。（可使用静态内部类）
     
十七、责任链模式 Chain of Responsibility Pattern</br>
     为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
     拦截的类（责任连）都实现统一接口。
     
十八、享元模式 Flyweight Pattern</br>
     主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。

十九、解释器模式 Interpreter Pattern</br>
     定义一个语法，定义一个解释器，该解释器处理该语法句子。
 
二十、中介者模式 Mediator Pattern</br>
     用一个中介对象来封装一系列的对象交互。
   中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
   
二十一、备忘录模式 Memento Pattern</br>
     保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。
  在不破坏封装的前提下，存储关键对象的重要状态，从而可以在将来把对象还原到存储的那个状态。
  
二十二、原型模式 Prototype Pattern</br>
     这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

二十三、访问者模式 Visitor Pattern</br>
     使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。
</br>
（完）
